<?php

/**
 * @file
 * Install hooks for API module.
 */

/**
 * Implements hook_schema().
 */
function api_schema() {
  $schema['api_project'] = array(
    'description' => 'Name and type of each project',
    'fields' => array(
      'project_name' => array(
        'description' => 'Short name of the project',
        'type' => 'varchar',
        'length' => '50',
        'not null' => TRUE,
        'default' => '',
      ),
      'project_title' => array(
        'description' => 'Long name of the project',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'project_type' => array(
        'description' => 'module, theme, core, etc.',
        'type' => 'varchar',
        'length' => '30',
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'primary key' => array('project_name'),
    'indexes' => array(
      'project_type' => array('project_type'),
    ),
  );

  $schema['api_branch'] = array(
    'description' => 'Information about each branch within an {api_project}',
    'fields' => array(
      'branch_id' => array(
        'description' => 'Primary key, numeric ID',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'branch_name' => array(
        'descripton' => 'Short name for branch, unique within project only',
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'core_compatibility' => array(
        'description' => '6.x, 7.x, etc.',
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'preferred' => array(
        'description' => 'Whether this is the preferred branch within this core compatibility for this project',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 1,
      ),
      'project' => array(
        'description' => '{api_project}.{project_name}',
        'type' => 'varchar',
        'length' => '50',
        'not null' => TRUE,
        'default' => '',
      ),
      'data' => array(
        'description' => 'Serialized data on directories etc.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'Displayed name of branch including project',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'weight' => array(
        'description' => 'Ordering weight',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'last_updated' => array(
        'description' => 'When this branch was last checked for updated files',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'update_frequency' => array(
        'description' => 'Number of seconds to wait before updating again',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'queue_valid' => array(
        'description' => 'File parse jobs before this time are invalid',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'queued' => array(
        'description' => 'Time when this branch was queued for update checking',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('branch_id'),
    'unique keys' => array(
      'project_name' => array('project', 'branch_name'),
    ),
    'indexes' => array(
      'weight' => array('weight'),
      'branch_name' => array('branch_name'),
      'last_updated' => array('last_updated'),
      'core_preferred' => array('core_compatibility', 'preferred'),
    ),
  );

  $schema['api_php_branch'] = array(
    'description' => 'Information about PHP reference branches (e.g., php.net functions)',
    'fields' => array(
      'branch_id' => array(
        'description' => 'Primary key, numeric ID',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'Administratively-displayed name',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'data' => array(
        'description' => 'Serialized data on URLs etc.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'reference_type' => array(
        'description' => 'Type of references: php, api, etc.',
        'type' => 'varchar',
        'length' => '30',
        'not null' => TRUE,
        'default' => '',
      ),
      'last_updated' => array(
        'description' => 'When this branch was last updated',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'update_frequency' => array(
        'description' => 'Number of seconds to wait before updating again',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'queued' => array(
        'description' => 'Time when this branch was queued for update checking',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('branch_id'),
    'indexes' => array(
      'last_updated' => array('last_updated'),
    ),
  );

  $schema['api_documentation'] = array(
    'fields' => array(
      'did' => array(
        'description' => 'Primary key, documentation ID',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'branch_id' => array(
        'description' => 'Branch ID',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'object_name' => array(
        'description' => 'Name of object',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'member_name' => array(
        'description' => 'For class members, the name without Class::',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'object_type' => array(
        'description' => 'Type of object: function, class, etc.',
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'title' => array(
        'description' => 'Display title',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'file_name' => array(
        'description' => 'Full path of file',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'summary' => array(
        'description' => 'Short description from documentation',
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'documentation' => array(
        'description' => 'Full documentation',
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'code' => array(
        'description' => 'Formatted source code',
        'type' => 'blob',
        'size' => 'big',
        'not null' => TRUE,
      ),
      'start_line' => array(
        'description' => 'Start line of object in file',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'see' => array(
        'description' => 'See also references',
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'var' => array(
        'description' => 'Variable type from var tag',
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'throws' => array(
        'description' => 'Throws section',
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'deprecated' => array(
        'description' => 'Deprecated descriptions',
        'type' => 'text',
        'size' => 'medium',
        'not null' => FALSE,
      ),
      'class_did' => array(
        'description' => 'Documentation ID of class this is part of',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'namespace' => array(
        'description' => 'Namespace, if any',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'namespaced_name' => array(
        'description' => 'Fully-qualified namespaced name, starting with backslash',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'modifiers' => array(
        'description' => 'Modifiers such as static, abstract, etc.',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'is_drupal' => array(
        'description' => 'Whether this is or is not a Drupal object',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 1,
      ),
    ),
    'primary key' => array('did'),
    'indexes' => array(
      'object_name' => array('object_name', 'branch_id', 'object_type'),
      'object_type' => array('object_type'),
      'branch_id' => array('branch_id'),
      'title' => array('title'),
      'class_did' => array('class_did'),
      'file_name' => array('file_name'),
      'member_name' => array('member_name'),
      'namespace' => array('namespace'),
      'namespaced_name' => array('namespaced_name'),
      'branch_object_class' => array('branch_id', 'object_type', 'class_did'),
      'is_drupal' => array('is_drupal'),
    ),
  );

  $schema['api_php_documentation'] = array(
    'fields' => array(
      'did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'branch_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'object_name' => array(
        'type' => 'varchar',
        'length' => '127',
        'not null' => TRUE,
        'default' => '',
      ),
      'member_name' => array(
        'description' => 'For class members, the name without Class::',
        'type' => 'varchar',
        'length' => 127,
        'not null' => TRUE,
        'default' => '',
      ),
      'object_type' => array(
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'documentation' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('did'),
    'indexes' => array(
      'object_name' => array('object_name', 'branch_id', 'object_type'),
      'object_type' => array('object_type'),
      'branch_id' => array('branch_id'),
      'member_name' => array('member_name'),
    ),
  );

  $schema['api_external_documentation'] = array(
    'fields' => array(
      'did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'branch_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'object_name' => array(
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'namespaced_name' => array(
        'description' => 'Fully-qualified namespaced name, starting with backslash',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'title' => array(
        'description' => 'Display title',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'member_name' => array(
        'description' => 'For class members, the name without Class::',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'object_type' => array(
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'summary' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'url' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('did'),
    'indexes' => array(
      'object_name' => array('object_name', 'branch_id', 'object_type'),
      'object_type' => array('object_type'),
      'branch_id' => array('branch_id'),
      'member_name' => array('member_name'),
      'namespaced_name' => array('namespaced_name'),
      'title' => array('title'),
    ),
  );

  $schema['api_file'] = array(
    'fields' => array(
      'did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'modified' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'queued' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'basename' => array(
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'primary key' => array('did'),
    'indexes' => array(
      'basename' => array('basename'),
    ),
  );

  $schema['api_function'] = array(
    'fields' => array(
      'did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'signature' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'parameters' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'return_value' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('did'),
  );

  $schema['api_reference_storage'] = array(
    'documentation' => 'Keep track of references.',
    'fields' => array(
      'object_name' => array(
        'type' => 'varchar',
        'mysql_type' => 'varbinary(255)',
        'length' => '255',
      ),
      'branch_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'object_type' => array(
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'from_did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'extends_did' => array(
        'description' => 'If this is a class or interface inheritance, the computed did value',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
    ),
    'indexes' => array(
      'from_did' => array('from_did'),
      'object_name' => array('object_name'),
      'object_type' => array('object_type'),
      'branch_id' => array('branch_id'),
      'extends_did' => array('extends_did'),
    ),
  );

  $schema['api_reference_counts'] = array(
    'documentation' => 'Aggregated counts of certain references',
    'fields' => array(
      'branch_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'reference_type' => array(
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'object_name' => array(
        'type' => 'varchar',
        'mysql_type' => 'varbinary(255)',
        'length' => '255',
        'not null' => TRUE,
      ),
      'reference_count' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
    ),
    'indexes' => array(
      'branch_id' => array('branch_id'),
      'reference_type' => array('reference_type'),
      'object_name' => array('object_name'),
    ),
  );

  $schema['api_overrides'] = array(
    'description' => 'Keep track of method, property, and class constant parents.',
    'fields' => array(
      'did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'overrides_did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'documented_did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'indexes' => array(
      'did' => array('did'),
      'overrides_did' => array('overrides_did'),
    ),
  );

  $schema['api_members'] = array(
    'description' => 'Keep track of class members, including inherited members.',
    'fields' => array(
      'class_did' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'did' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'member_alias' => array(
        'description' => 'Alias of the member, for trait inheritance',
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'default' => NULL,
      ),
    ),
    'indexes' => array(
      'did' => array('did'),
      'class_did' => array('class_did'),
    ),
  );

  $schema['api_namespace'] = array(
    'documentation' => 'Keep track of namespace and use declarations.',
    'fields' => array(
      'did' => array(
        'description' => 'Documentation ID of file',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'object_type' => array(
        'description' => 'namespace or use_alias',
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'class_alias' => array(
        'description' => 'Alias of the class, blank for namespaces',
        'type' => 'varchar',
        'mysql_type' => 'varbinary(255)',
        'length' => '255',
        'default' => '',
      ),
      'class_name' => array(
        'description' => 'Name of class or namespace',
        'type' => 'varchar',
        'mysql_type' => 'varbinary(255)',
        'length' => '255',
        'default' => '',
      ),
    ),
    'indexes' => array(
      'did' => array('did'),
      'object_type' => array('object_type', 'class_name'),
      'class_alias' => array('class_alias'),
    ),
  );

  return $schema;
}

/**
 * Implements hook_enable().
 */
function api_enable() {
  module_load_include('inc', 'api', 'api.db');

  // Make sure a few things are reset. This is only necessary for running tests.
  drupal_static_reset('api_get_branches');
  drupal_static_reset('api_get_branch_names');
  drupal_static_reset('api_get_php_branches');

  // Create the PHP branch if it doesn't already exist.
  $result = db_select('api_php_branch', 'b')
    ->fields('b', array('title'))
    ->condition('reference_type', 'php')
    ->range(0, 1)
    ->execute()
    ->fetchCol();

  if (count($result) < 1) {
    // Create new PHP branch.
    $branch = new stdClass();
    $branch->reference_type = 'php';
    $branch->title = 'PHP functions';
    $branch->update_time = 604800;
    $branch->data = array(
      'summary' => 'http://doc.php.net/downloads/json/php_manual_en.json',
      'path' => 'http://php.net/!function',
    );
    api_save_php_branch($branch);

    // Turn off cron runs until the API administration page has been visited,
    // because it can take a long time to parse the PHP branch.
    variable_set('api_do_cron', 0);
  }

  // Make sure that the comment body field exists for our fake node type.
  if (module_exists('comment')) {
    $info = (object) array('type' => 'api');
    _comment_body_field_create($info);
  }
}

/**
 * Implements hook_disable().
 */
function api_disable() {
  // If there are any files branches in the database, warn the user about
  // uninstalling the module.
  $file_branches = db_select('api_branch', 'b')
    ->fields('b', array('branch_id'))
    ->execute()
    ->fetchCol();
  if (count($file_branches) > 0) {
    drupal_set_message(t('If you plan to uninstall the API module (removing all its data), you need to first re-enable the API module and delete all the branches from the administration screen. The data deletion might otherwise run out of time if you attempt to do it all during the uninstall process.'));
  }
}

/**
 * Implements hook_update_last_removed().
 */
function api_update_last_removed() {
  return 6116;
}

/**
 * Ensure that the comment body field exists.
 */
function api_update_7100() {
  if (module_exists('comment')) {
    $info = (object) array('type' => 'api');
    _comment_body_field_create($info);
  }
}

/**
 * Add the {api_php_documentation} table to the database.
 */
function api_update_7101() {
  // Create new table.
  db_create_table('api_php_documentation', array(
    'fields' => array(
      'did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'branch_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'object_name' => array(
        'type' => 'varchar',
        'length' => '127',
        'not null' => TRUE,
        'default' => '',
      ),
      'member_name' => array(
        'description' => 'For class members, the name without Class::',
        'type' => 'varchar',
        'length' => 127,
        'not null' => TRUE,
        'default' => '',
      ),
      'object_type' => array(
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'documentation' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('did'),
    'indexes' => array(
      'object_name' => array('object_name', 'branch_id', 'object_type'),
      'object_type' => array('object_type'),
      'branch_id' => array('branch_id'),
      'member_name' => array('member_name'),
    ),
  ));

  // Populate from existing {api_documentation} records.
  $branches = db_select('api_branch', 'b')
    ->fields('b', array('branch_id'))
    ->condition('b.type', 'php')
    ->execute()
    ->fetchCol();
  $select = db_select('api_documentation', 'd')
    ->fields('d', array(
      'did',
      'branch_id',
      'object_name',
      'member_name',
      'object_type',
      'documentation',
    ))
    ->condition('d.branch_id', $branches);
  db_insert('api_php_documentation')
    ->fields(array(
      'did',
      'branch_id',
      'object_name',
      'member_name',
      'object_type',
      'documentation',
    ))
    ->from($select)
    ->execute();

  // Delete existing {api_documentation} records from PHP branches.
  db_delete('api_documentation')
    ->condition('branch_id', $branches)
    ->execute();
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7102() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Change the data type for the object_name field in {api_reference_storage}.
 */
function api_update_7103() {
  // Update the field to the new definition.
  db_drop_index('api_reference_storage', 'object_name');
  db_change_field('api_reference_storage', 'object_name', 'object_name',
    array(
      'type' => 'varchar',
      'mysql_type' => 'varbinary(127)',
      'length' => '127',
    ),
    array('indexes' => array('object_name' => array('object_name'))));

  // Also reparse everything, because the old field definition left things
  // in a bad state.
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Remove fields {api_reference_storage}.to_did and {api_overrides}.root_did.
 */
function api_update_7104() {
  db_drop_index('api_reference_storage', 'to_did');
  db_drop_field('api_reference_storage', 'to_did');

  db_drop_index('api_overrides', 'root_did');
  db_drop_field('api_overrides', 'root_did');
}

/**
 * Make two {api.documentation} fields longer.
 */
function api_update_7106() {
  db_drop_index('api_documentation', 'file_name');
  db_drop_index('api_documentation', 'object_name');
  db_change_field('api_documentation', 'file_name', 'file_name',
    array(
      'description' => 'Full path of file',
      'type' => 'varchar',
      'length' => '255',
      'not null' => TRUE,
      'default' => '',
    ),
    array('indexes' => array('file_name' => array('file_name'))));
  db_change_field('api_documentation', 'object_name', 'object_name',
    array(
      'description' => 'Name of object',
      'type' => 'varchar',
      'length' => '255',
      'not null' => TRUE,
      'default' => '',
    ),
    array(
      'indexes' => array(
        'object_name' => array(
          'object_name',
          'branch_id',
          'object_type',
        ),
      ),
    ));
}

/**
 * Remove outdated information from the database.
 */
function api_update_7107(&$sandbox) {
  // The information being deleted here should have been deleted when things
  // changed, but in previous versions of the API module, it wasn't. Also, the
  // node removals can take a long time, so they are done in batches. The rest
  // is fast, so it's only done on the first pass.
  $sandbox['#finished'] = 0;

  // See if this is the first pass, and do the fast updates.
  if (!isset($sandbox['total'])) {
    // This variable can be left over from a Drupal 6 upgrade.
    variable_del('node_preview_api');

    // Remove items in api_documentation that do not correspond to existing
    // file branches.
    $file_branches = db_select('api_branch', 'b')
      ->fields('b', array('branch_id'))
      ->condition('type', 'files')
      ->execute()
      ->fetchCol();

    if (count($file_branches)) {
      db_delete('api_documentation')
        ->condition('branch_id', $file_branches, 'NOT IN')
        ->execute();
    }

    // Delete entries in API tables that don't correspond to existing entries
    // in {api_documentation}.
    // These are queries using a WHERE EXISTS, and there is no apparent way
    // to write it using the database API, so use ANSI syntax.
    // @codingStandardsIgnoreStart
    db_query("DELETE FROM {api_file} WHERE NOT EXISTS ( SELECT * FROM {api_documentation} d WHERE d.did = {api_file}.did )");
    db_query("DELETE FROM {api_function} WHERE NOT EXISTS ( SELECT * FROM {api_documentation} d WHERE d.did = {api_function}.did )");
    db_query("DELETE FROM {api_members} WHERE NOT EXISTS ( SELECT * FROM {api_documentation} d WHERE d.did = {api_members}.did )");
    db_query("DELETE FROM {api_overrides} WHERE NOT EXISTS ( SELECT * FROM {api_documentation} d WHERE d.did = {api_overrides}.did )");
    db_query("DELETE FROM {api_reference_storage} WHERE NOT EXISTS ( SELECT * FROM {api_documentation} d WHERE d.did = {api_reference_storage}.from_did )");
    // @codingStandardsIgnoreEnd

    // Initiate batch for future calls.
    $sandbox['last'] = 0;
    $sandbox['count'] = 0;

    $query = db_select('node', 'n')
      ->fields('n', array('nid'))
      ->condition('n.type', 'api');
    $query->leftJoin('api_documentation', 'd', 'n.nid = d.did');
    $sandbox['total'] = $query
      ->isNull('d.object_type')
      ->countQuery()
      ->execute()
      ->fetchField();
    if ($sandbox['total'] > 0) {
      $sandbox['#finished'] = 0;
    }
    else {
      $sandbox['#finished'] = 1;
    }
  }
  else {
    // Subsequent invocations: find and delete nodes of type API that don't
    // have corresponding entries in {api_documentation}.
    $query = db_select('node', 'n')
      ->fields('n', array('nid'))
      ->condition('n.type', 'api');
    $query->leftJoin('api_documentation', 'd', 'n.nid = d.did');
    $nids = $query
      ->isNull('d.object_type')
      ->range(0, 500)
      ->execute()
      ->fetchCol();
    $count = count($nids);
    $done = 0;
    while ($done < $count) {
      $this_batch = array_slice($nids, $done, 100);
      $done += 100;
      node_delete_multiple($this_batch);
    }

    $sandbox['count'] += 1;
    $sandbox['last'] += $count;
    $sandbox['#finished'] = min(1, $sandbox['count'] / $sandbox['total']);
    if ($count == 0) {
      // Make sure if we found nothing, we count as being done.
      $sandbox['#finished'] = 1;
    }
  }
}

/**
 * This update has been removed.
 */
function api_update_7108() {
  // This used to create the api_extends table, but since the table is
  // removed in a later update, don't bother now (if we are running this
  // version of the file, we don't need it).
}

/**
 * Update table structure of branches and projects.
 */
function api_update_7109() {
  // Create the PHP branch table.
  db_create_table('api_php_branch', array(
    'description' => 'Information about php branches (e.g., php.net functions)',
    'fields' => array(
      'branch_id' => array(
        'description' => 'Primary key, numeric ID',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'Administratively-displayed name',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'data' => array(
        'description' => 'Serialized data on URLs etc.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'reference_type' => array(
        'description' => 'Type of references: php, etc.',
        'type' => 'varchar',
        'length' => '30',
        'not null' => TRUE,
        'default' => '',
      ),
      'last_updated' => array(
        'description' => 'When this branch was last updated',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'update_frequency' => array(
        'description' => 'Number of seconds to wait before updating again',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('branch_id'),
    'indexes' => array(
      'last_updated' => array('last_updated'),
    ),
  ));

  // Populate the PHP branch table.
  $results = db_select('api_branch', 'b')
    ->fields('b', array('branch_id', 'branch_name', 'data'))
    ->condition('b.type', 'php')
    ->execute();
  foreach ($results as $record) {
    $fields = array();
    $fields['branch_id'] = $record->branch_id;
    $fields['title'] = $record->branch_name;
    $fields['last_updated'] = variable_get('api_last_updated_' . $record->branch_id, 0);
    variable_del('api_last_updated_' . $record->branch_id);
    $fields['reference_type'] = 'php';
    $data = unserialize($record->data);
    $fields['update_frequency'] = (isset($data['update_time']) ? $data['update_time'] : 0);
    unset($data['update_time']);
    $fields['data'] = serialize($data);
    db_insert('api_php_branch')
      ->fields($fields)
      ->execute();
  }

  // Delete PHP branches from the branch table.
  db_delete('api_branch')
    ->condition('type', 'php')
    ->execute();

  // Figure out what the current default branch is.
  $id = variable_get('api_default_branch', -1);
  $default_branch = NULL;
  if ($id > 0) {
    $default_branch = db_select('api_branch', 'b')
      ->fields('b')
      ->condition('branch_id', $id)
      ->execute()
      ->fetchObject();
  }
  if (!isset($default_branch) || !isset($default_branch->branch_id) || $default_branch->branch_id != $id) {
    // Just use the first branch by weight.
    $default_branch = db_select('api_branch', 'b')
      ->fields('b')
      ->orderBy('weight')
      ->execute()
      ->fetchObject();
  }
  $default_project = (isset($default_branch->project) ? $default_branch->project : NULL);

  // Create the project table.
  db_create_table('api_project', array(
    'description' => 'Name and type of each project',
    'fields' => array(
      'project_name' => array(
        'description' => 'Short name of the project',
        'type' => 'varchar',
        'length' => '50',
        'not null' => TRUE,
        'default' => '',
      ),
      'project_title' => array(
        'description' => 'Long name of the project',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'project_type' => array(
        'description' => 'module, theme, core, etc.',
        'type' => 'varchar',
        'length' => '30',
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'primary key' => array('project_name'),
    'indexes' => array(
      'project_type' => array('project_type'),
    ),
  ));

  // Populate the project table.
  $query = db_select('api_branch', 'b');
  $query->addField('b', 'project', 'project_name');
  $query->groupBy('project_name');
  $query->addExpression('MIN(project_title)', 'project_title');
  $results = $query
    ->condition('b.type', 'files')
    ->execute();
  foreach ($results as $record) {
    $fields = array();
    // Try to guess the project type.
    $fields['project_type'] = (strtolower($record->project_name) == 'drupal') ? 'core' : 'module';
    if (!isset($default_project)) {
      $default_project = $record->project_name;
    }

    // Set the other two fields from the information in the branch table.
    $fields['project_title'] = $record->project_title;
    $fields['project_name'] = $record->project_name;

    db_insert('api_project')
      ->fields($fields)
      ->execute();
  }

  if (isset($default_project)) {
    variable_set('api_default_project', $default_project);
  }

  // Modify the branch table -- add and remove fields.
  db_add_field('api_branch', 'core_compatibility',
    array(
      'description' => '6.x, 7.x, etc.',
      'type' => 'varchar',
      'length' => '31',
      'not null' => TRUE,
      'default' => '',
    ));

  db_add_field('api_branch', 'preferred',
    array(
      'description' => 'Whether this is the preferred branch within this core compatibility for this project',
      'type' => 'int',
      'size' => 'tiny',
      'unsigned' => TRUE,
      'not null' => TRUE,
      'default' => 1,
    ),
    array(
      'indexes' => array(
        'core_preferred' => array(
          'core_compatibility', 'preferred',
        ),
      ),
    ));

  db_add_field('api_branch', 'last_updated',
    array(
      'description' => 'When this branch was last checked for updated files',
      'type' => 'int',
      'not null' => TRUE,
      'default' => 0,
    ),
    array('indexes' => array('last_updated' => array('last_updated'))));

  db_add_field('api_branch', 'update_frequency',
    array(
      'description' => 'Number of seconds to wait before updating again',
      'type' => 'int',
      'not null' => TRUE,
      'default' => 0,
    ));

  db_drop_field('api_branch', 'type');
  db_drop_index('api_branch', 'status');
  db_drop_field('api_branch', 'status');
  db_drop_index('api_branch', 'project_title');
  db_drop_field('api_branch', 'project_title');

  db_drop_unique_key('api_branch', 'project_name');
  db_change_field('api_branch', 'project', 'project',
    array(
      'description' => '{api_project}.{project_name}',
      'type' => 'varchar',
      'length' => '50',
      'not null' => TRUE,
      'default' => '',
    ),
    array(
      'unique_keys' => array(
        'project_name' => array('project', 'branch_name'),
      ),
    ));

  // Attempt to set the core compatibility field values and variable.
  variable_set('api_default_core_compatibility', _api_extract_compatibility(isset($default_branch->branch_name) ? $default_branch->branch_name : ''));

  $branches = db_select('api_branch', 'b')
    ->fields('b')
    ->execute();
  foreach ($branches as $branch) {
    $branch->core_compatibility = _api_extract_compatibility($branch->branch_name);
    db_update('api_branch')
      ->condition('branch_id', $branch->branch_id)
      ->fields((array) $branch)
      ->execute();
  }

  return 'The structure of API branches and projects has changed, and they have new fields whose values were guessed. Check the API module administration pages to make sure all of your branches and projects are correct.';
}

/**
 * Attempts to assign a core compatibility, given a branch name.
 *
 * This is only used in the api_update_7109() function, where it is trying
 * to assign values to the new core compatibility field/variables by guessing.
 */
function _api_extract_compatibility($str) {
  // Special case for 4.7.
  if (strpos($str, '4.7') !== FALSE) {
    return '4.7';
  }

  // For the other major versions, first try to find NUM.x, then NUM., then
  // just NUM in the string, to avoid false matches.
  $nums = array('5', '6', '7', '8', '9');
  foreach ($nums as $num) {
    if (strpos($str, $num . '.x') !== FALSE) {
      return $num . '.x';
    }
  }

  foreach ($nums as $num) {
    if (strpos($str, $num . '.') !== FALSE) {
      return $num . '.x';
    }
  }

  foreach ($nums as $num) {
    if (strpos($str, $num) !== FALSE) {
      return $num . '.x';
    }
  }

  // Just return a default value.
  return '7.x';
}

/**
 * Add field to branch database table to validate queue entries.
 */
function api_update_7110() {
  // Add the queue valid timestamp field to the branch table. Note that for
  // existing branches, having a value of zero is good, since that means
  // that existing queue entries without the timestamp are still valid.
  db_add_field('api_branch', 'queue_valid',
    array(
      'description' => 'File parse jobs before this time are invalid',
      'type' => 'int',
      'not null' => TRUE,
      'default' => 0,
    ));
}

/**
 * Add fields to branch database tables for updates queue.
 */
function api_update_7111() {
  db_add_field('api_branch', 'queued',
    array(
      'description' => 'Time when this branch was queued for update checking',
      'type' => 'int',
      'not null' => TRUE,
      'default' => 0,
    ));

  db_add_field('api_php_branch', 'queued',
    array(
      'description' => 'Time when this branch was queued for update checking',
      'type' => 'int',
      'not null' => TRUE,
      'default' => 0,
    ));
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7112() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7113() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Make function signature field be text instead of varchar.
 */
function api_update_7114() {
  db_change_field('api_function', 'signature', 'signature',
    array(
      'type' => 'text',
      'size' => 'medium',
      'not null' => TRUE,
    ));
}

/**
 * Remove obsolete autocomplete files and variables.
 */
function api_update_7115() {
  // Remove autocomplete variables.
  $names = db_select('variable', 'v')
    ->condition('name', 'api\_autocomplete\_path\_%', 'LIKE')
    ->fields('v', array('name'))
    ->execute()
    ->fetchCol();
  foreach ($names as $name) {
    variable_del($name);
  }

  // Remove auto-complete files.
  file_unmanaged_delete_recursive('public://api');

  // Remove any items in the delete files queue.
  $queue = DrupalQueue::get('api_delete');
  $queue->deleteQueue();
}

/**
 * Reset branches as sorting has been updated.
 */
function api_update_7116() {
  module_load_include('inc', 'api', 'api.db');
  api_reset_branches();
}

/**
 * Remove blank documentation entries.
 */
function api_update_7117() {
  module_load_include('module', 'api');

  // Find any entries in api_documentation with blank names. There should not
  // be many.
  $dids = db_select('api_documentation', 'd')
    ->fields('d', array('did'))
    ->condition('d.object_name', '')
    ->execute()
    ->fetchCol();

  // Remove them from all associated tables.
  api_delete_items($dids);
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7118() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Add the {api_namespace} table and namespace fields to the database.
 */
function api_update_7119() {
  // Create new table.
  db_create_table('api_namespace', array(
    'documentation' => 'Keep track of namespace and use declarations.',
    'fields' => array(
      'did' => array(
        'description' => 'Documentation ID of file',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'object_type' => array(
        'description' => 'namespace or use_alias',
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'class_alias' => array(
        'description' => 'Alias of the class, blank for namespaces',
        'type' => 'varchar',
        'mysql_type' => 'varbinary(127)',
        'length' => '127',
        'default' => '',
      ),
      'class_name' => array(
        'description' => 'Name of class or namespace',
        'type' => 'varchar',
        'mysql_type' => 'varbinary(127)',
        'length' => '127',
        'default' => '',
      ),
    ),
    'indexes' => array(
      'did' => array('did'),
      'object_type' => array('object_type'),
      'class_alias' => array('class_alias'),
    ),
  ));

  db_add_field('api_documentation', 'namespace',
    array(
      'description' => 'Namespace, if any',
      'type' => 'varchar',
      'length' => '255',
      'not null' => TRUE,
      'default' => '',
    ),
    array('indexes' => array('namespace' => array('namespace'))));

  db_add_field('api_documentation', 'namespaced_name',
    array(
      'description' => 'Fully-qualified namespaced name, starting with backslash',
      'type' => 'varchar',
      'length' => '255',
      'not null' => TRUE,
      'default' => '',
    ),
    array('indexes' => array('namespaced_name' => array('namespaced_name'))));
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7120() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Add modifiers field to {api_documentation} table.
 */
function api_update_7121() {
  db_add_field('api_documentation', 'modifiers',
    array(
      'description' => 'Modifiers such as static, abstract, etc.',
      'type' => 'varchar',
      'length' => '255',
      'not null' => TRUE,
      'default' => '',
    ));
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7122() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7123() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Add table {api_external_documentation}.
 */
function api_update_7124() {
  db_create_table('api_external_documentation', array(
    'fields' => array(
      'did' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'branch_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'object_name' => array(
        'type' => 'varchar',
        'length' => '127',
        'not null' => TRUE,
        'default' => '',
      ),
      'namespaced_name' => array(
        'description' => 'Fully-qualified namespaced name, starting with backslash',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'title' => array(
        'description' => 'Display title',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'member_name' => array(
        'description' => 'For class members, the name without Class::',
        'type' => 'varchar',
        'length' => 127,
        'not null' => TRUE,
        'default' => '',
      ),
      'object_type' => array(
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'summary' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
      'url' => array(
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'primary key' => array('did'),
    'indexes' => array(
      'object_name' => array('object_name', 'branch_id', 'object_type'),
      'object_type' => array('object_type'),
      'branch_id' => array('branch_id'),
      'member_name' => array('member_name'),
      'namespaced_name' => array('namespaced_name'),
      'title' => array('title'),
    ),
  ));
}

/**
 * Add deprecated field to {api_documentation} table.
 */
function api_update_7125() {
  db_add_field('api_documentation', 'deprecated',
    array(
      'description' => 'Deprecation descriptions',
      'type' => 'text',
      'size' => 'medium',
      'not null' => FALSE,
    ));
}

/**
 * Adjust the weight field on api_branch to be an INT field.
 */
function api_update_7126() {
  db_drop_index('api_branch', 'weight');
  db_change_field('api_branch', 'weight', 'weight',
    array(
      'description' => 'Ordering weight',
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
      'default' => 0,
    ),
    array('indexes' => array('weight' => array('weight'))));
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7127() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Make the api_documentation.code field binary instead of text.
 */
function api_update_7128() {
  db_change_field('api_documentation', 'code', 'code',
    array(
      'description' => 'Formatted source code',
      'type' => 'blob',
      'size' => 'big',
      'not null' => TRUE,
    ));
}

/**
 * Add an index to the api_documentation table.
 */
function api_update_7129() {
  db_add_index(
    'api_documentation',
    'branch_object_class',
    array('branch_id', 'object_type', 'class_did'));
}

/**
 * Make the api_external_documentation.url field text instead of varchar.
 */
function api_update_7130() {
  module_load_include('inc', 'api', 'api.db');

  db_change_field('api_external_documentation', 'url', 'url',
    array(
      'type' => 'text',
      'size' => 'medium',
      'not null' => TRUE,
    ));

  // Due to a previous code update, it would be a good idea to reset the
  // branch list too.
  api_reset_branches();
}

/**
 * Make the api_external_documentation.object_name longer.
 */
function api_update_7131() {
  db_change_field('api_external_documentation', 'object_name', 'object_name',
    array(
      'type' => 'varchar',
      'length' => '255',
      'not null' => TRUE,
      'default' => '',
    ));
}

/**
 * Add field is_drupal to the api_documentation table.
 */
function api_update_7132() {
  db_add_field('api_documentation', 'is_drupal',
    array(
      'description' => 'Whether this is or is not a Drupal object',
      'type' => 'int',
      'size' => 'tiny',
      'unsigned' => TRUE,
      'not null' => TRUE,
      'default' => 1,
    ),
    array('indexes' => array('is_drupal' => array('is_drupal'))));
}

/**
 * Add field extends_did to api_reference_storage table; remove api_extends.
 */
function api_update_7133() {
  // Add the new field to api_reference_storage.
  db_add_field('api_reference_storage', 'extends_did',
    array(
      'description' => 'If this is a class or interface inheritance, the computed did value',
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => FALSE,
    ),
    array('indexes' => array('extends_did' => array('extends_did'))));

  // Delete the {api_extends} table, if it even exists.
  if (db_table_exists('api_extends')) {
    db_drop_table('api_extends');
  }
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7134() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Warn users about funcsummary.txt.
 */
function api_update_7135() {
  return 'php.net reference branches have changed. If you are using a funcsummary.txt URL in a PHP reference branch, you need to point it to http://doc.php.net/downloads/json/php_manual_en.json instead. You should also update infrequently (weekly).';
}

/**
 * Repair database for missing file records.
 */
function api_update_7136() {
  // Find file records in api_documentation without records in api_file.
  // These cause the API module to repeatedly parse the same file. There should
  // not be any, but there may be a few.
  $query = db_select('api_documentation', 'd');
  $query->leftJoin('api_file', 'f', 'd.did = f.did');
  $query
    ->fields('d', array('did', 'file_name'))
    ->isNull('f.basename')
    ->condition('d.object_type', 'file');
  $results = $query->execute();
  foreach ($results as $file) {
    $info = pathinfo($file->file_name);
    db_insert('api_file')
      ->fields(array(
        'did' => $file->did,
        'basename' => $info['basename'],
        'modified' => 0,
        'queued' => 0,
      ))
      ->execute();
  }
}

/**
 * Add alias field to api_members table.
 */
function api_update_7137() {
  db_add_field('api_members', 'member_alias',
    array(
      'description' => 'Alias of the member, for trait inheritance',
      'type' => 'varchar',
      'length' => 127,
      'not null' => FALSE,
      'default' => NULL,
    ));
}

/**
 * Mark all files for reparse, due to various updates to the parsing code.
 */
function api_update_7138() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Mark all files for reparse, due to various updates to the parsing code.
 */
function api_update_7139() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Increase size of various columns.
 */
function api_update_7140() {
  db_change_field('api_documentation', 'var', 'var',
    array(
      'description' => 'Variable type from var tag',
      'type' => 'text',
      'size' => 'medium',
      'not null' => TRUE,
    ));

  db_change_field('api_documentation', 'member_name', 'member_name',
    array(
      'description' => 'For class members, the name without Class::',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    ));

  db_change_field('api_documentation', 'member_name', 'member_name',
    array(
      'description' => 'For class members, the name without Class::',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    ));

  db_change_field('api_members', 'member_alias', 'member_alias',
    array(
      'description' => 'Alias of the member, for trait inheritance',
      'type' => 'varchar',
      'length' => 255,
      'not null' => FALSE,
      'default' => NULL,
    ));

  db_change_field('api_namespace', 'class_name', 'class_name',
    array(
      'description' => 'Name of class or namespace',
      'type' => 'varchar',
      'mysql_type' => 'varbinary(255)',
      'length' => '255',
      'default' => '',
    ));

  db_change_field('api_namespace', 'class_alias', 'class_alias',
    array(
      'description' => 'Alias of the class, blank for namespaces',
      'type' => 'varchar',
      'mysql_type' => 'varbinary(255)',
      'length' => '255',
      'default' => '',
    ));
  db_change_field('api_reference_storage', 'object_name', 'object_name',
    array(
      'type' => 'varchar',
      'mysql_type' => 'varbinary(255)',
      'length' => '255',
    ));
}

/**
 * Mark all files for reparse, due to various updates to the parsing code.
 */
function api_update_7141() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Add the {api_reference_counts} table to the database.
 */
function api_update_7142() {
  // Create new table.
  db_create_table('api_reference_counts', array(
    'documentation' => 'Aggregated counts of certain references',
    'fields' => array(
      'record_id' => array(
        'type' => 'serial',
        'not null' => TRUE,
      ),
      'branch_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'reference_type' => array(
        'type' => 'varchar',
        'length' => '31',
        'not null' => TRUE,
        'default' => '',
      ),
      'object_name' => array(
        'type' => 'varchar',
        'mysql_type' => 'varbinary(255)',
        'length' => '255',
        'not null' => TRUE,
      ),
      'reference_count' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('record_id'),
    'indexes' => array(
      'branch_id' => array('branch_id'),
      'reference_type' => array('reference_type'),
      'object_name' => array('object_name'),
    ),
  ));

  // Mark one file from each branch for reparse, to trigger population of
  // this table over the next cron run(s).
  module_load_include('inc', 'api', 'api.db');
  $select = db_select('api_documentation', 'ad')
    ->condition('object_type', 'file')
    ->groupBy('ad.branch_id');
  $select->addExpression('MIN(ad.did)', 'fdid');
  $dids = $select->execute()->fetchCol();
  api_mark_items_for_reparse($dids);
  return format_string('@count files marked for reparse, starting at next cron run, to populate new table', array('@count' => count($dids)));
}

/**
 * Mark all classes using traits for reparsing.
 */
function api_update_7143() {
  module_load_include('inc', 'api', 'api.db');
  $select = db_select('api_reference_storage', 'ars')
    ->condition('object_type', 'trait')
    ->fields('ars', array('from_did'))
    ->groupBy('ars.from_did');
  $dids = $select->execute()->fetchCol();
  api_mark_items_for_reparse($dids);
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => count($dids)));
}

/**
 * Mark all files for reparse, due to various updates to the parsing code.
 */
function api_update_7144() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Remove the record_id field and primary key from api_reference_counts table.
 */
function api_update_7145() {
  // You cannot drop the primary key if there is still a serial field in
  // the table. So, first modify the field, then drop the primary key, then
  // drop the field.
  db_change_field('api_reference_counts', 'record_id', 'record_id',
    array(
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
    ));
  db_drop_primary_key('api_reference_counts');
  db_drop_field('api_reference_counts', 'record_id');
}

/**
 * Mark all files for reparse, due to some updates to the parsing code.
 */
function api_update_7146() {
  $count = api_update_mark_for_reparse();
  return format_string('@count files marked for reparse, starting at next cron run', array('@count' => $count));
}

/**
 * Add class_name to the namespace table's object_type index.
 */
function api_update_7147() {
  db_drop_index('api_namespace', 'object_type');
  db_add_index('api_namespace', 'object_type', array('object_type', 'class_name'));
}

  /**
 * Remove variables and other data on uninstall.
 */
function api_uninstall() {
  // Delete variables: some wildcards and some exact variable names.
  $names = db_select('variable', 'v')
    ->condition(db_or()
      ->condition('name', 'comment\_%\_api', 'LIKE')
      ->condition('name', 'api\_last\_updated\_%', 'LIKE')
    )
    ->fields('v', array('name'))
    ->execute()
    ->fetchCol();
  $names[] = 'api_default_branch';
  $names[] = 'api_do_cron';
  $names[] = 'comment_api';
  $names[] = 'api_default_core_compatibility';
  $names[] = 'api_default_project';
  $names[] = 'api_opensearch_name';
  $names[] = 'api_opensearch_description';
  $names[] = 'api_breaks_where';
  $names[] = 'api_breaks_tag';

  foreach ($names as $name) {
    variable_del($name);
  }

  // Remove all tasks from the queues.
  foreach (array('api_parse', 'api_branch_update', 'api_node_delete') as $name) {
    $queue = DrupalQueue::get($name);
    $queue->deleteQueue();
  }

  // Delete all API nodes, in batches of 100.
  // This might run out of time, but we warned about it in hook_disable(),
  // so just plunge ahead and hope for the best.
  $nids = db_select('node', 'n')
    ->condition('type', 'api')
    ->fields('n', array('nid'))
    ->execute()
    ->fetchCol();
  $count = count($nids);
  $done = 0;
  while ($done < $count) {
    $this_batch = array_slice($nids, $done, 100);
    $done += 100;
    node_delete_multiple($this_batch);
  }
}

/**
 * Works like api_mark_for_reparse() without loading modules.
 */
function api_update_mark_for_reparse() {
  // Get rid of everything currently in the parse queue.
  $queue = DrupalQueue::get('api_parse');
  $queue->deleteQueue();

  // Set all files to reparse: say they are not yet queued, and that the
  // last time they were touched was long ago.
  $time_in_past = 52;
  return db_update('api_file')
    ->fields(array(
      'modified' => $time_in_past,
      'queued' => 0,
    ))
    ->execute();
}
