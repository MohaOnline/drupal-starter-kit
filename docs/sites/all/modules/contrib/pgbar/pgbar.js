"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Generated by CoffeeScript 2.5.1
var $, PgbarItem, formatNumber;
$ = jQuery;

if (Drupal.formatNumber != null) {
  formatNumber = function formatNumber(now) {
    return Drupal.formatNumber(now, 0);
  };
} else {
  formatNumber = function formatNumber(now) {
    var num, rest, zeros;
    num = ''; // Add thousand separators to the number

    zeros = 0;
    now = Math.round(now);

    if (now === 0) {
      return '0';
    }

    while (now > 0) {
      while (zeros > 0) {
        num = '0' + num;
        zeros -= 1;
      }

      rest = now % 1000;
      zeros = 3 - rest.toString().length;
      num = rest + ',' + num;
      now = (now - rest) / 1000;
    } // cut last thousand separator from output.


    return num.slice(0, num.length - 1);
  };
}

PgbarItem = /*#__PURE__*/function () {
  function PgbarItem(settings1, wrapper) {
    var _this = this;

    _classCallCheck(this, PgbarItem);

    this.settings = settings1;
    this.wrapper = wrapper;
    this.current = 0;
    this.counter = $('.pgbar-counter', wrapper);
    this.bars = $('.pgbar-current', wrapper);
    this.target = $('.pgbar-target', wrapper);
    this.target.html(formatNumber(this.settings.target));
    this.needed = $('.pgbar-needed', wrapper);

    if (this.settings.extractor) {
      this.extractor = this.settings.extractor;
    } else if (this.settings.find_at) {
      this.extractor = function (data) {
        var d, j, len, p, parts, value;
        parts = _this.settings.find_at.split('.').filter(function (i) {
          return i !== '';
        });
        d = data; // walk the path defined by parts

        for (j = 0, len = parts.length; j < len; j++) {
          p = parts[j];

          if (d[p]) {
            d = d[p];
          } else {
            // nothing found: return 0
            return 0;
          }
        }

        if (typeof d === "number" || typeof d === "string") {
          value = parseInt(d, 10);

          if (!isNaN(value)) {
            return value;
          }
        } // return 0 if we did not find a number


        return 0;
      };
    } else {
      this.extractor = function (data) {
        return parseInt(data.pgbar[_this.settings.field_name][_this.settings.delta]);
      };
    }
  }

  _createClass(PgbarItem, [{
    key: "selectTarget",
    value: function selectTarget(current) {
      var t, targets;
      t = 1; // copy the array

      targets = this.settings.targets.concat();

      while (targets.length > 0) {
        t = targets.shift();

        if (current * 100 / t <= parseInt(this.settings.threshold, 10)) {
          return t;
        }
      }

      return t;
    }
  }, {
    key: "poll",
    value: function poll() {
      var _this2 = this;

      var callback, registry;
      registry = Drupal.behaviors.polling.registry;

      callback = function callback(data) {
        var to_abs;
        to_abs = _this2.extractor(data);

        if (to_abs !== _this2.current) {
          _this2.animate(to_abs);
        }
      };

      return registry.registerUrl(this.settings.pollingURL, this.settings.id, callback);
    }
  }, {
    key: "animate",
    value: function animate(to_abs) {
      var _this3 = this;

      var from_abs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.current;
      var best_target, diff, duration, from, resetCounters, target, to;
      target = this.settings.target;
      best_target = this.selectTarget(to_abs);

      if (best_target !== target) {
        target = best_target;
        this.target.html(formatNumber(target));
        this.needed.html(formatNumber(target - to_abs));
      }

      if (this.settings.inverted) {
        from = 1 - from_abs / target;
        to = 1 - to_abs / target;
        diff = from - to;
      } else {
        from = from_abs / target;
        to = to_abs / target;
        diff = to - from;
      }

      this.counter.html(formatNumber(from_abs));
      duration = 500 + 1000 * diff;

      resetCounters = function resetCounters(num, fx) {
        return _this3.counter.html(formatNumber(num));
      };

      if (this.settings.vertical) {
        this.bars.height(from * 100 + '%');
        this.bars.animate({
          height: to * 100 + '%'
        }, {
          duration: duration
        });
      } else {
        this.bars.width(from * 100 + '%');
        this.bars.animate({
          width: to * 100 + '%'
        }, {
          duration: duration
        });
      }

      this.wrapper.animate({
        val: to_abs
      }, {
        duration: duration,
        step: resetCounters
      });
      return this.current = to_abs;
    }
  }, {
    key: "animateInitially",
    value: function animateInitially() {
      var _this4 = this;

      var animation;

      animation = function animation() {
        return _this4.animate(_this4.settings.current);
      };

      return window.setTimeout(animation, 2000);
    }
  }]);

  return PgbarItem;
}();

PgbarItem.fromElement = function ($element) {
  var id, settings;
  id = $element.attr('id');
  settings = Drupal.settings.pgbar[id];
  settings['id'] = id;
  settings['inverted'] = $element.data('pgbarInverted');
  settings['vertical'] = $element.data('pgbarDirection') === 'vertical';
  return new PgbarItem(settings, $element);
};

Drupal.behaviors.pgbar = {};

Drupal.behaviors.pgbar.attach = function (context, settings) {
  return $('.pgbar-wrapper[id]', context).each(function () {
    var item;
    item = PgbarItem.fromElement($(this)); // Do not animate initially for an external source with initial count 0.
    // This doubles the animation due to the timeout timings between pgbar and
    // polling.

    if (item.settings['external_url']) {
      return item.poll();
    } else if (item.settings['autostart']) {
      item.animateInitially();
      return item.poll();
    }
  });
};